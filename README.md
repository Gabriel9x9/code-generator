


# Achieve

**任何模块都是需求分析，实现思路，开发实现。**

## first

1. 生成静态、动态文件，通过 Main 方法执行，得到完整代码
2. 命令行接收输入
3. 工具封装

静态文件复制：Hutool库

动态文件：模板引擎 FreeMaker 模板 + 数据模型

命令行开发：
CLI [commend、option、parameter]  可选、强制交互式
子命令：声明式、编程式
命令模式（设计模式）【行为类设计模式】：将请求的发送者（客户端）和接收者（执行请求的对象）解耦。
每个操作对应一个独立的命令类，广泛用于统一处理多种复杂操作，持续增加新命令，处理复杂组合命令
exp：人 -- 遥控器 -- 电视

实现：
需求，子命令：generate,list,config
分解：
1. 创建命令执行器
2. 实现子命令
3. 提供项目的全局调用入口
4. 构建jar报
5. 测试使用
6. 简化使用（封装脚本）

## Second

1. 制作工具整体规划
     生成器制作工具 --> 代码生成器 --> 目标代码
     思路：配置文件加上参数去生成模板文件及可执行文件


2. 制作工具核心设计

元信息（配置文件），一般用JSON格式，配置：
代码生成器的基本信息，
生成文件信息
数据模型信息

3. 制作工具开发

根据配置文件得到一个meta对象，后保存在内存中，避免重复创建对象的开销。  -- 单例模式

4. 开发后进行优化

可移植性,功能,健壮性,可扩展性等角度.


5. 配置能力增强

增加 SpringBoot 项目模板.
具体功能:
1.替换生成的代码包名。
2.控制是否生成帖子相关功能的文件。
3.控制是否需要开启跨域功能。
4.自定义Knife4jConfig接口文档配置信息。
5.自定义MySQL配置信息。
6.控制是否开启Redis
7.控制是否开启Elasticsearch。


添加needGit命令行参数
规则统一：一个参数控制一个文件，同参数控制多个文件（多文件配置相同的condition；配置文件分组）
同组参数封装为一个类
Picocli的复杂参数的参数组特性 @ArgGroup
定义可选择开启的参数组（套娃，一个命令类去触发另一个）

动态模板和元信息配置文件的强绑定关系
--> 制作工具根据项目文件生成对于动态模板文件和元信息配置文件
输入：基本信息+输入文件+模型参数+输出规则
输出：动态模板文件和元信息配置文件

工作空间隔离
分布制作
”有状态“
读取文件夹，制作其下多个文件的模板。加search=="BaseResponce"，对比替换前后内容看是否更改生成方式。
输入多文件，inputFilePathList
文件过滤：range（范围），rule（规则）、value（值）
文件分组（新增分组和同组下新加文件）fileInfo - 有分组的、无分组的
模型分组

bug：
幂等性：多次执行相同操作，得到相同结果
可能动态文件变静态，加hasTemplateFile变量


# Knowledge

1. 扩展思路：一个工具类可以用于多个模块的实现
2. 模板设计：分离数据处理和展示、重用、维护、安全性、性能
3. 单元测试：junit
4. 模板中文件：生成动态、静态文件
5. 用反射动态打印属性信息
6. 单例模式
双检锁进行并发控制
饿汉式
7. 路径分隔符可以混用
8. 项目优化：
- 可移植性(不同环境可以运行) 如路径
- 功能优化（项目介绍、精简版）
- 健壮性（代码复杂性，分支判断）
输入校验、异常处理、故障恢复、自动重试、降级
- 可扩展性(功能,性能,资源可扩展性)

9. 配置文件控制
分组可以将同一个文件放在不同组，有多个条件判断。
group时不校验
ftl采用**FreeMarker宏定义**，将重复的代码定义成”组件“（可以传不同参数，在其他地方引用）

动态生成模板文件和元信息配置文件





# Problems

1. Runnable & Callable
2. jar包运行
3. volatile关键字
保持变量值的一致性（可见性），防止对其修饰的变量相关的操作被重排列。  -- 保证变量的可见性和禁止指令重排序，不能保证原子性和顺序性。
volatile和synchronized的区别
4. 制作工具优化

健壮性:
此项目的关键就是元信息配置文件，要用默认值补充空值
1. 表格梳理每个字段的校验规则和默认值
2. 自定义异常类
3. 编写校验类
   基础信息校验和填充，fileConfig校验和默认值填充、fileInfo默认值填充，modelConfig校验和默认值填充
4. 圈复杂度    
   重构、快速抽取方法；卫语句（进入主要逻辑前添加条件检查）；使用工具类

可扩展性    
定义枚举值
模板方法模式(父类规定标准执行流程,子类具体实现每一步骤);
- 梳理流程:MainGenerate:复制原始文件,代码生成,构建jar包,封装脚本,生成精简版;
- 构建父类;
- 抽取方法;
- 编写具体实现子类;
- 调用生成器
  之后扩展只需覆写每个步骤的方法,或新增具体实现子类.

5. 跨域问题

6. Lambda表达式编程、复用变量、抽象封装方法
